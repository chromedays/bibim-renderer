#version 450

#define WORK_GROUP_SIZE 32
layout (local_size_x = WORK_GROUP_SIZE, local_size_y = WORK_GROUP_SIZE, local_size_z = 1) in;

layout (set = 0, binding = 0, rgba32f) uniform writeonly image2D outImage;
layout (set = 0, binding = 1, rgba32f) uniform readonly image2D uEnvMap;

const float PI = 3.1415926535897932384626433832795;

vec3 texCoordToNormal(ivec2 texCoord, ivec2 size) {
    vec2 uv = vec2(float(texCoord.x) / float(size.x), float(texCoord.y) / float(size.y));
    float phi = uv.x * 2 * PI;
    float theta = uv.y * PI;
    vec3 normal = normalize(vec3(
        cos(phi) * sin(theta),
        cos(theta),
        sin(phi) * sin(theta)
    ));

    return normal;
}

ivec2 normalToTexCoord(vec3 normal, ivec2 size) {
    vec2 reconstructedUV = vec2(atan(normal.z, normal.x) / (2 * PI), acos(normal.y) / PI);
    if (reconstructedUV.x < 0) {
        reconstructedUV.x += 1.0;
    }

    return ivec2(reconstructedUV * vec2(size));
}

void main() {
    ivec2 size = imageSize(outImage);
    ivec2 texCoord = ivec2(gl_GlobalInvocationID.xy);

    if (texCoord.x >= size.x || texCoord.y >= size.y) {
        return;
    }

    vec3 normal = texCoordToNormal(texCoord, size);

    vec3 up = vec3(0.0, 1.0, 0.0);
    vec3 right = cross(normal, up);
    up = cross(right, normal);

    vec3 irradiance = vec3(0.0);
    float sampleDelta = 0.025;
    float nrSamples = 0.0; 
    for(float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta)
    {
        for(float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta)
        {
            // spherical to cartesian (in tangent space)
            vec3 tangentSample = vec3(sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi));
            // tangent space to world
            vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * normal; 
            
            ivec2 sampleTexCoord = normalToTexCoord(sampleVec, imageSize(uEnvMap));

            irradiance += imageLoad(uEnvMap, sampleTexCoord).rgb * cos(theta) * sin(theta);
            nrSamples++;
        }
    }
    irradiance = PI * irradiance * (1.0 / float(nrSamples));

    // vec2 uv = vec2(float(texCoord.x) / float(size.x), float(texCoord.y) / float(size.y));
    // imageStore(outImage, texCoord, vec4(imageLoad(uEnvMap, texCoord).rgb * vec3(uv.x, 1.0, uv.y), 1.0));
    // imageStore(outImage, texCoord, vec4(uv.x, 0, uv.y, 1.0));
    // imageStore(outImage, texCoord, vec4(reconstructedUV.x, 0, reconstructedUV.y, 1.0));
    // imageStore(outImage, texCoord, vec4(normal, 1.0));
    imageStore(outImage, texCoord, vec4(irradiance.rgb , 1.0));
}